<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Sheenam Narula</title>
    <link>http://sheenamnarula1993.github.io/</link>
    <description>Recent content on Sheenam Narula</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 31 Jul 2019 00:00:00 +0530</lastBuildDate>
    
	    <atom:link href="http://sheenamnarula1993.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Import Vs Require</title>
      <link>http://sheenamnarula1993.github.io/post/import-require/</link>
      <pubDate>Wed, 31 Jul 2019 00:00:00 +0530</pubDate>
      
      <guid>http://sheenamnarula1993.github.io/post/import-require/</guid>
      <description>

&lt;h5 id=&#34;syntax-of-import-export&#34;&gt;Syntax of import/export :&lt;/h5&gt;

&lt;p&gt;file : exportVar.js&lt;/p&gt;

&lt;p&gt;export const m = 1 ;&lt;/p&gt;

&lt;p&gt;file : importVar.js&lt;/p&gt;

&lt;p&gt;import {m} from exportVar.js&lt;/p&gt;

&lt;h5 id=&#34;syntax-of-require&#34;&gt;Syntax of require :&lt;/h5&gt;

&lt;p&gt;file : exportVar.js&lt;/p&gt;

&lt;p&gt;const m = 1;&lt;/p&gt;

&lt;p&gt;module.exports = m ;&lt;/p&gt;

&lt;p&gt;file: importVar.js&lt;/p&gt;

&lt;p&gt;const m = require(&amp;lsquo;./exportVar.js&amp;rsquo;)&lt;/p&gt;

&lt;h3 id=&#34;loading-strategy&#34;&gt;Loading Strategy :&lt;/h3&gt;

&lt;p&gt;Mainly import/export i.e. ES6 structure, involves asynchronous loading of modules.
But in case of require(), synchronous loading of modules takes place.
It means, if a file needs to load 5 modules, in case of ES6 structure, second module won&amp;rsquo;t wait for first module to be loaded completely.But in case of require, loading of second module will start after loading of first module is completed.&lt;/p&gt;

&lt;p&gt;This is the key difference between import/export and require.&lt;/p&gt;

&lt;p&gt;To get more deep in to this, we need to know how ES6 structure is working and how it is different from Common js.&lt;/p&gt;

&lt;p&gt;The key difference between the Common JS and ES6 modules is when to know the shape of module.&lt;/p&gt;

&lt;p&gt;In Common JS, when a module is exported, the steps performed before execution is given in this figure.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sheenamnarula1993.github.io/img/common-js-steps.png&#34; alt=&#34;Example image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Here the common mistake that most of the developers make in understanding the loading step.
In loading step, it is determined that what kind of thing is pointed by absolute path that is obtained on completion of resolution step.If it is Node.js native module, then dynamic linking of module is decided. On the other hand, if it is JSON file, the content is loaded in memory for further use.
Here is the trick, in wrapper step, before evaluation, the loaded Javasacript is wrapped in a function. For e.g.&lt;/p&gt;

&lt;p&gt;In file , example.js&lt;/p&gt;

&lt;p&gt;const m = 1;&lt;/p&gt;

&lt;p&gt;module.exports.m = m;&lt;/p&gt;

&lt;p&gt;code is actually wrapped and passed to evaluation in below function format :&lt;/p&gt;

&lt;p&gt;function (exports, require, module, **filename, **dirname) {
const m = 1;
module.exports.m = m;
}&lt;/p&gt;

&lt;p&gt;Here the exports is a parameter for wrapper function and it is a normal javascript object. So when the wrapper function is evaluated, it returns the exports object which is then used as a result of require(). The main point to note here is that, there is no way to determine as what kind of module is being exported by Common JS until the evaluation of wrapper.&lt;/p&gt;

&lt;p&gt;On the other hand, if we use import/export i.e. ES6 feature, the equivalent code of above example is :&lt;/p&gt;

&lt;p&gt;In file , example.js&lt;/p&gt;

&lt;p&gt;export const m = 1;&lt;/p&gt;

&lt;p&gt;import {m} from &amp;lsquo;./example.js&amp;rsquo;&lt;/p&gt;

&lt;p&gt;In this case, the shape of m is actually determined at the parsing step i.e before evaluation step. Actually, while parsing, and before evaluation, a Module Record is created, where a static listing of modules that have been exported in code are listed and verified. That means, it is verified first whether the exported m exists or not and link between import file and exported module i.e. m is eastablished. Only after creation of this module record, code is actually evaluated.
Here the key point is, before even evaluation of code, the shape of module is known or we can say that, import/export is resolved before evaluation of code.&lt;/p&gt;

&lt;h2 id=&#34;challenge-for-node-js&#34;&gt;Challenge for Node.js :&lt;/h2&gt;

&lt;p&gt;Here is the challenge for Node.js comes up when exported module is not an ESM i.e ECMASCRIPT Module but a Common JS module because while importing with import statement or according to ES6 structure, shape of module should be known before evaluation but in case of Common JS module it becomes impossible to determine shape of code before evaluation step due to wrapper function.&lt;/p&gt;

&lt;p&gt;To resolve this challenge, one proposal came up in which it was proposed that if a module is ESM module, then it will be directly added to list of Module Record but if it is not i.e if it is a Common JS module, then rather than giving error or giving up, the verification step will be left in pending state and a process of evaluation of that module will be executed. After getting confirmation of existence of that module, Module Record will be created.&lt;/p&gt;

&lt;p&gt;But again for the implementation of this proposal, Node js requires some mechanism to identify whether the module is ESM or Common JS Module. Various approaches have been suggested but Michael Jackson Script is supposed to be accepted.&lt;/p&gt;

&lt;h3 id=&#34;michael-jackson-script&#34;&gt;Michael Jackson Script :&lt;/h3&gt;

&lt;p&gt;In this a new file extension *.mjs is supposed to be introduced for ESM modules.
Right now, Node is distinguishing between the modules like this :&lt;/p&gt;

&lt;p&gt;.node files : native modules&lt;/p&gt;

&lt;p&gt;.js : Common JS modules&lt;/p&gt;

&lt;p&gt;.json : JSON files&lt;/p&gt;

&lt;p&gt;Now *.mjs will specify that the module is ESM and it should be loaded with the right mechanism.
The key point here is by knowing the extensions of file, loading mechanism will be selected. For Common JS module, evaluation of module will be done first so that verification of existence can be done.&lt;/p&gt;

&lt;p&gt;E.g. There are two files common.js and esm.mjs&lt;/p&gt;

&lt;p&gt;import c from &amp;lsquo;./common.js&amp;rsquo; will be treated as Common js module&lt;/p&gt;

&lt;p&gt;import e from &amp;lsquo;./esm.mjs&amp;rsquo; will be treated as ESM module&lt;/p&gt;

&lt;h2 id=&#34;what-to-do-if-i-want-to-use-es6-import-export-feature-in-project&#34;&gt;What to do if i want to use ES6 import/export feature in project?&lt;/h2&gt;

&lt;h4 id=&#34;answer-is-babel&#34;&gt;Answer is Babel&lt;/h4&gt;

&lt;p&gt;If we want to use import/export feature of ES6, we need to use babel which transpiles code in Common JS. Here is a point which needs to be understood that Babel only converts the syntax to Common JS syntax so that it can be resolved by Node js, but implementation is according to ESM only.&lt;/p&gt;

&lt;p&gt;Example: If we see named imports like&lt;/p&gt;

&lt;p&gt;import {a,b} from &amp;lsquo;ab&amp;rsquo;;&lt;/p&gt;

&lt;p&gt;This syntax will work only if ab is an ESM. But if it is Common JS module, it is not possible to use this syntax as shape of code can&amp;rsquo;t be determined until evaluation is done in this case.&lt;/p&gt;

&lt;p&gt;But here BABEL does a perfect job for us by converting ES6 syntax to Common JS syntax and we get the required implementation.&lt;/p&gt;

&lt;h2 id=&#34;significance-of-using-es6-structure&#34;&gt;Significance of using ES6 structure :&lt;/h2&gt;

&lt;p&gt;In case of ES6 structure, the first step of loading the contents of file from disk is quite similar but may happen asynchronously. When the content of files is available, they are parsed. While parsing, the shape of exported module is determined and linked to respective import.That means all exports and imports will know their targets before evaluation itself i.e. they are resolved before execution step and that too happen asynchronously.
In node.js terms, we can say that loading scripts, resolution of import and export and evaluation of module code occur over multiple turns of the event loop.&lt;/p&gt;

&lt;h3 id=&#34;practical-example&#34;&gt;Practical Example :&lt;/h3&gt;

&lt;p&gt;module a and b, both does not exist. b is imported using require and a is imported using import. Now due to use of require, existence of b is not verified and code does not throw error for non-existence of b. But in case of module a, existence of a is verified and code throws error for a at very early stage i.e at parsing step only.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sheenamnarula1993.github.io/img/example-import-require.png&#34; alt=&#34;Example image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sheenamnarula1993.github.io/img/error-import-require.png&#34; alt=&#34;Example image&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Node-Docker-Aws Part-2</title>
      <link>http://sheenamnarula1993.github.io/post/express-docker-aws-2/</link>
      <pubDate>Sat, 29 Jun 2019 00:00:00 +0530</pubDate>
      
      <guid>http://sheenamnarula1993.github.io/post/express-docker-aws-2/</guid>
      <description>

&lt;p&gt;I am assuming that an amazon account is already set up to use the Amazon Elastic Container Service(ECS).&lt;/p&gt;

&lt;p&gt;Steps to deploy two containers(app + database) -&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Dockerise app&lt;/li&gt;
&lt;li&gt;Create Registry(ECR)&lt;/li&gt;
&lt;li&gt;Upload app image to ECR&lt;/li&gt;
&lt;li&gt;Create task definition with two containers&lt;/li&gt;
&lt;li&gt;Create a cluster&lt;/li&gt;
&lt;li&gt;Create a service and run it.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;practical-explanation-of-steps&#34;&gt;Practical Explanation of steps :&lt;/h2&gt;

&lt;h3 id=&#34;1-dockerise-app&#34;&gt;1. Dockerise app&lt;/h3&gt;

&lt;p&gt;for this you can check this practice project : &lt;a href=&#34;https://github.com/sheenamnarula/node-graphql-docker-aws&#34; target=&#34;_blank&#34;&gt;https://github.com/sheenamnarula/node-graphql-docker-aws&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-create-registry-ecr&#34;&gt;2. Create Registry(ECR)&lt;/h3&gt;

&lt;p&gt;We need to keep image of app somewhere from where it is pulled while starting container.We can do two things here. Either we can use Docker Hub or we can use AWS Elastic Container Registry(ECR) service. In this tutorial,i am using ECR to keep the created images.&lt;/p&gt;

&lt;p&gt;Log in to web console into your prefered region and choose ECR from services.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sheenamnarula1993.github.io/img/aws-images/choose-ECR.png&#34; alt=&#34;Example image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;There create a repository to store image of your app.After creating repository, you will see a button &amp;ldquo;View Push Commands&amp;rdquo; on right side.
&lt;img src=&#34;http://sheenamnarula1993.github.io/img/aws-images/button-view-commands.png&#34; alt=&#34;Example image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;On clicking that button, you will get some commands that will be used to push image of app to this repository.
&lt;img src=&#34;http://sheenamnarula1993.github.io/img/aws-images/push-commands.png&#34; alt=&#34;Example image&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;3-upload-image-to-ecr&#34;&gt;3 . Upload image to ECR&lt;/h3&gt;

&lt;p&gt;Run the commands, to push the image to ECR.&lt;/p&gt;

&lt;h4 id=&#34;command-1&#34;&gt;Command 1.&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;    aws ecr get-login --no-include-email --region ap-south-1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will help you to login to aws through cli.(Note : Install aws-cli to run these commands.)
( Link to install aws cli : &lt;a href=&#34;https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-install.html&#34; target=&#34;_blank&#34;&gt;https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-install.html&lt;/a&gt; )&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sheenamnarula1993.github.io/img/aws-images/aws-login.png&#34; alt=&#34;Example image&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;command-2&#34;&gt;Command 2.&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;  docker build -t node-express .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This command will help you in building image of your app. Run this command in the folder containing the app. -t is to give the name to your image. You can also customize it according to your preference so that you can find the created image easily.
&lt;img src=&#34;http://sheenamnarula1993.github.io/img/aws-images/aws-login.png&#34; alt=&#34;Example image&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;command-3&#34;&gt;Command 3.&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;     docker tag node-express:latest 597357263415.dkr.ecr.ap-south-1.amazonaws.com/node-express:latest
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This command is used to tag your created image to the ECR.
&lt;img src=&#34;http://sheenamnarula1993.github.io/img/aws-images/build-image.png&#34; alt=&#34;Example image&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;command-4&#34;&gt;Command 4 .&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;     docker push 597357263415.dkr.ecr.ap-south-1.amazonaws.com/node-express:latest
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This command is used to push the created image to ECR. This command can take few minutes to execute.
&lt;img src=&#34;http://sheenamnarula1993.github.io/img/aws-images/pushing-image.png&#34; alt=&#34;Example image&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;3-create-task-definitions&#34;&gt;3. Create Task definitions&lt;/h3&gt;

&lt;p&gt;As we run docker commands like docker run in docker cli, here task definitions are used for this purpose. Every task consists of - docker containers details, port mappings, network details, environment variables, volumes if any, and the most important thing, image of app.
Choose Task Definitions in left navigation pane.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sheenamnarula1993.github.io/img/aws-images/task-definition.png&#34; alt=&#34;Example image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Here we will define two containers in one task as running app willl contain api container and database container.&lt;/p&gt;

&lt;h4 id=&#34;first-container-api-container&#34;&gt;First Container : Api Container&lt;/h4&gt;

&lt;p&gt;Copy the url of your image that we pushed in ECR in second step.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sheenamnarula1993.github.io/img/aws-images/image-url.png&#34; alt=&#34;Example image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Click on Create New Task Definition and choose EC2 and then click on next.
&lt;img src=&#34;http://sheenamnarula1993.github.io/img/aws-images/ec2-selection-task-def.png&#34; alt=&#34;Example image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Here you will get a form to define your task.
&lt;img src=&#34;http://sheenamnarula1993.github.io/img/aws-images/form-1-taskdef.png&#34; alt=&#34;Example image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Fill out the required fields and click on Add Containers.
&lt;img src=&#34;http://sheenamnarula1993.github.io/img/aws-images/add-container-button.png&#34; alt=&#34;Example image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;In add container form, specify the container name and memory required.
Then give the port mappings i.e host port and container port.
&lt;img src=&#34;http://sheenamnarula1993.github.io/img/aws-images/container-1-port.png&#34; alt=&#34;Example image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Give Environment variables using Key-value pair(In this project, we are using mongo db as environment variable)
&lt;img src=&#34;http://sheenamnarula1993.github.io/img/aws-images/env-variables.png&#34; alt=&#34;Example image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;In network links, you can declare the linking of other containers with this container simply by following syntax - othercontainer: alias
&lt;img src=&#34;http://sheenamnarula1993.github.io/img/aws-images/link.png&#34; alt=&#34;Example image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Here we are running database in second container and we are gonna name it as mongo-container(yet to be defined)
We are linking this container to database container.
Then click on create and you will get your api container created.&lt;/p&gt;

&lt;h4 id=&#34;second-container-database-container&#34;&gt;Second Container : Database Container&lt;/h4&gt;

&lt;p&gt;For this container, we need a mongo image and this can be directly pulled from Docker Hub. Here is the required url for mongo image : registry.hub.docker.com/library/mongo:latest&lt;/p&gt;

&lt;p&gt;Now we need to be careful while naming second container as we have mentioned in the linking of first container as &amp;ldquo;mongo-container&amp;rdquo;. So for correct linking, we need to keep the name of our db container as &amp;ldquo;mongo-container&amp;rdquo;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sheenamnarula1993.github.io/img/aws-images/container-2.png&#34; alt=&#34;Example image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;and also mention the hostname as mongo-container.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sheenamnarula1993.github.io/img/aws-images/hostname.png&#34; alt=&#34;Example image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Now click on create option and you will get your task definition created with two containers.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sheenamnarula1993.github.io/img/aws-images/added-containers.png&#34; alt=&#34;Example image&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;4-create-cluster&#34;&gt;4. Create Cluster :&lt;/h3&gt;

&lt;p&gt;Cluster is where container runs.&lt;/p&gt;

&lt;p&gt;Choose Clusters from left navigation pane and choose create cluster.Creating cluster is like setting up an EC2 instance.After clicking on create cluster, choose EC2+Linux and create cluster with options vpc - create new vpc group,instance type- m4.large and number of required instances.
&lt;img src=&#34;http://sheenamnarula1993.github.io/img/aws-images/create-cluster-button.png&#34; alt=&#34;Example image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sheenamnarula1993.github.io/img/aws-images/selecting-ec2-linux-cluster.png&#34; alt=&#34;Example image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Configuration of cluster :
&lt;img src=&#34;http://sheenamnarula1993.github.io/img/aws-images/configure-cluster.png&#34; alt=&#34;Example image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sheenamnarula1993.github.io/img/aws-images/configure-cluster-2.png&#34; alt=&#34;Example image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Now you can see the created cluster, on clicking that cluster, you can see tabs for task definition, ec2 instance and services.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sheenamnarula1993.github.io/img/aws-images/created-cluster.png&#34; alt=&#34;Example image&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;5-create-service&#34;&gt;5. Create Service :&lt;/h3&gt;

&lt;p&gt;Service is used to run your defined tasks in cluster.
Click on create service and fill the required fields.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sheenamnarula1993.github.io/img/aws-images/configure-service.png&#34; alt=&#34;Example image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sheenamnarula1993.github.io/img/aws-images/configure-service-2.png&#34; alt=&#34;Example image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Creating service :
&lt;img src=&#34;http://sheenamnarula1993.github.io/img/aws-images/creating-service.png&#34; alt=&#34;Example image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sheenamnarula1993.github.io/img/aws-images/created-service.png&#34; alt=&#34;Example image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Choose the task definition that have been created in step 3 and run the service.&lt;/p&gt;

&lt;p&gt;Initially it will show pending state and soon it will be in running state.
&lt;img src=&#34;http://sheenamnarula1993.github.io/img/aws-images/pending-status.png&#34; alt=&#34;Example image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;When it is in running state, you can go to cluster and then click on ec2 instance.
&lt;img src=&#34;http://sheenamnarula1993.github.io/img/aws-images/running-status.png&#34; alt=&#34;Example image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;On clicking that, details of that instance will appear. From there copy the public dns.
&lt;img src=&#34;http://sheenamnarula1993.github.io/img/aws-images/ec2-public-dns-url.png&#34; alt=&#34;Example image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Paste the copied address in browser and you can see your app in running state.
&lt;img src=&#34;http://sheenamnarula1993.github.io/img/aws-images/working-example.png&#34; alt=&#34;Example image&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Node-Docker-Aws Part-1</title>
      <link>http://sheenamnarula1993.github.io/post/express-docker-aws-1/</link>
      <pubDate>Fri, 28 Jun 2019 00:00:00 +0530</pubDate>
      
      <guid>http://sheenamnarula1993.github.io/post/express-docker-aws-1/</guid>
      <description>

&lt;p&gt;First of all, make a project in node-express-mongo and dockerise it. Here I am giving a github link of a basic node-express app made along with graphql as this has become my favourite language because of its advantage of providing independence to front-end developers.&lt;/p&gt;

&lt;h4 id=&#34;github-link-for-dockerised-app-https-github-com-sheenamnarula-node-graphql-docker-aws&#34;&gt;Github link for dockerised app : &lt;a href=&#34;https://github.com/sheenamnarula/node-graphql-docker-aws&#34; target=&#34;_blank&#34;&gt;https://github.com/sheenamnarula/node-graphql-docker-aws&lt;/a&gt;&lt;/h4&gt;

&lt;h1 id=&#34;docker-file&#34;&gt;Docker File&lt;/h1&gt;

&lt;p&gt;Lets understand first, what is the meaning of lines written in the docker file.&lt;/p&gt;

&lt;h2 id=&#34;from-node-8-9-0&#34;&gt;From node:8.9.0 -&lt;/h2&gt;

&lt;p&gt;This line specifies the base image.Every docker file starts with a FROM instruction. As we are writing here for node app, so we need to set a node environmnent for the app. Here node:&lt;version&gt; is the base image along with the required version for our app ie. 8.9.0&lt;/p&gt;

&lt;h2 id=&#34;workdir-app&#34;&gt;WORKDIR /app -&lt;/h2&gt;

&lt;p&gt;This line refers to a directory in which we are going to keep our application files.Basically WORKDIR sets a directory where another commands like COPY, RUN, CMD, ADD can be run. In short, it is providing an entry point of app directory.&lt;/p&gt;

&lt;h2 id=&#34;copy-package-json&#34;&gt;COPY package*.json ./ -&lt;/h2&gt;

&lt;p&gt;To start a project or run a project, we need to install node modules and as we know in a node app, package.json is a file where dependencies of project is documented. So we are copying package.json in working directory so that further instructions can install node modules using this file. Here package* refers to package.json and package.lock.json files.&lt;/p&gt;

&lt;h2 id=&#34;run-npm-install&#34;&gt;RUN npm install&lt;/h2&gt;

&lt;h2 id=&#34;run-npm-install-nodemon-babel-cli-babel-preset-env&#34;&gt;RUN npm install nodemon babel-cli babel-preset-env&lt;/h2&gt;

&lt;p&gt;These both lines contain RUN command. After copying package.json in work directory that is suppose to be entry point of our source files,using RUN command we are installing node modules and required dependencies for our project. Basically RUN command is used for the command that we run in a terminal and then it commits a new image which is further used by next instructions of docker file&lt;/p&gt;

&lt;h2 id=&#34;expose-3007&#34;&gt;EXPOSE 3007&lt;/h2&gt;

&lt;p&gt;This line is very important to understand as it defines which port of container is exposed.When we give any port with this command, that means that port of container is exposed.Means if we want to access app, we have to write the hostname simply i.e we need to write port 80 on browser. But if we write publish port in docker run command with expose port that means the app will be accesed through published port. In short, EXPOSE is used to open port for network but publish is used to map the opened port to public accessible port.&lt;/p&gt;

&lt;h2 id=&#34;copy-app&#34;&gt;COPY . /app -&lt;/h2&gt;

&lt;p&gt;Here we are copying the all content of app to our container working directory so that app can be run.&lt;/p&gt;

&lt;h2 id=&#34;cmd-npm-run-start&#34;&gt;CMD npm run start -&lt;/h2&gt;

&lt;p&gt;This line refers to executing the command that is required to start the project.&lt;/p&gt;

&lt;h3 id=&#34;difference-between-run-and-cmd&#34;&gt;Difference between RUN and CMD -&lt;/h3&gt;

&lt;p&gt;Here is an important difference between RUN and CMD :&lt;/p&gt;

&lt;h4 id=&#34;run&#34;&gt;RUN -&lt;/h4&gt;

&lt;p&gt;Basically RUN command triggers when we are building docker image. After RUN command, image is committed and next command uses that committed image.&lt;/p&gt;

&lt;h4 id=&#34;cmd&#34;&gt;CMD -&lt;/h4&gt;

&lt;p&gt;Basically CMD command triggers when we launch the created docker image.Dockerfile can have only one CMD command and it can be overriden while starting a container i.e. executing docker run $image $other_command&lt;/p&gt;

&lt;p&gt;This is all about a docker file. Environment variables can also be included using ENV command.
Now this is all about one container which will contain app. But here database required is mongo db and we also need a container for mongo db.&lt;/p&gt;

&lt;p&gt;NOTE : It is possible to run mongo db and app in one container but it will create problem in scaling because if we need to scale app, thereby we will be scaling mongo db as well and moreover, it is difficult to maintain same data availability for all container apps in this case. So we will have one container for mongo db service following microservice architecture i.e. every service is running independently.&lt;/p&gt;

&lt;p&gt;To manage more than one container we will go for a tool named Compose. Compose is a tool that is used to define and run multi-container docker applications.In this, a YAML file is used to configure multiple containers of application services.Then with a single command, we can create and start all the services using yaml configuration file.&lt;/p&gt;

&lt;p&gt;Here is the code for docker compose file and explanation of each line of code :&lt;/p&gt;

&lt;h1 id=&#34;explanation-of-docker-compose-file&#34;&gt;Explanation of Docker Compose file :&lt;/h1&gt;

&lt;h2 id=&#34;version-3&#34;&gt;version: &amp;ldquo;3&amp;rdquo; -&lt;/h2&gt;

&lt;p&gt;This line refers to the docker compose file format version.&lt;/p&gt;

&lt;h2 id=&#34;services&#34;&gt;services: -&lt;/h2&gt;

&lt;p&gt;This line refers to the start of container configurations.A service definition contains configuration that is applied to each container started for that service.&lt;/p&gt;

&lt;h2 id=&#34;app&#34;&gt;app:&lt;/h2&gt;

&lt;p&gt;This line refers to the name of your service.&lt;/p&gt;

&lt;h2 id=&#34;container-name-docker-node-mongo&#34;&gt;container_name: docker-node-mongo&lt;/h2&gt;

&lt;p&gt;By default, a random name is generated. To generate a meaningful name, we use container_name parameter in config.&lt;/p&gt;

&lt;h2 id=&#34;restart-always&#34;&gt;restart: always&lt;/h2&gt;

&lt;p&gt;By default behaviour of container is that it never restarts. By setting restart to always, we are making container to opt restarting behaviour.&lt;/p&gt;

&lt;h2 id=&#34;build&#34;&gt;build: .&lt;/h2&gt;

&lt;p&gt;This option is used when we have to make an image from a docker file. Relative path is given in this option so that docker can look for Dockerfile according to given path to build image.&lt;/p&gt;

&lt;h2 id=&#34;ports&#34;&gt;ports:&lt;/h2&gt;

&lt;h2 id=&#34;80-3007&#34;&gt;- &amp;ldquo;80:3007&amp;rdquo;&lt;/h2&gt;

&lt;p&gt;This option is used to mention the exposed port of container. HOST:CONTAINER is short syntax to metion ports.&lt;/p&gt;

&lt;p&gt;The long form syntax allows the configuration of additional fields that can’t be expressed in the short form.&lt;/p&gt;

&lt;p&gt;target: the port inside the container
published: the publicly exposed port
protocol: the port protocol (tcp or udp)
mode: host for publishing a host port on each node, or ingress for a swarm mode port to be load balanced.
ports:
-target: 80
published: 8080
protocol: tcp
mode: host&lt;/p&gt;

&lt;h2 id=&#34;depends-on&#34;&gt;depends_on:&lt;/h2&gt;

&lt;h2 id=&#34;mongo&#34;&gt;- mongo&lt;/h2&gt;

&lt;p&gt;This line express the dependencies of one container to other. To start a container,the containers on which it is dependent, will be started first&lt;/p&gt;

&lt;h2 id=&#34;mongo-1&#34;&gt;mongo:&lt;/h2&gt;

&lt;h2 id=&#34;container-name-mongo&#34;&gt;container_name: mongo&lt;/h2&gt;

&lt;h2 id=&#34;image-mongo&#34;&gt;image: mongo :&lt;/h2&gt;

&lt;p&gt;This will check the mongo image if it is available locally and in case of unavailability, image will be downloaded from docker hub(github for docker images).&lt;/p&gt;

&lt;h2 id=&#34;ports-1&#34;&gt;ports:&lt;/h2&gt;

&lt;h2 id=&#34;27017-27017&#34;&gt;- &amp;ldquo;27017:27017&amp;rdquo;&lt;/h2&gt;

&lt;p&gt;Here is on more command like depends_on i.e. links. But link is deprecated now. depends_on gives us start order but links just to link one container to another.But now, if containers are placed in same network, they can connect with each other by using their name.&lt;/p&gt;

&lt;p&gt;Now by running a single command, &amp;ldquo;docker-compose up&amp;rdquo;, we can see two containers running one is our app container and other is mongo container.&lt;/p&gt;

&lt;p&gt;Note: In project here is one commented line , &lt;code&gt;mongodb://mongo:27017/expGraphqlDemo&lt;/code&gt;. In this mongo is container name and 27017 is container&amp;rsquo;s published port.But for deployment purpose, we are making it configurable and will pass as environment variable while deployment.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Basic Docker Commands</title>
      <link>http://sheenamnarula1993.github.io/post/docker-basic-commands/</link>
      <pubDate>Mon, 24 Jun 2019 00:00:00 +0530</pubDate>
      
      <guid>http://sheenamnarula1993.github.io/post/docker-basic-commands/</guid>
      <description>

&lt;h3 id=&#34;show-commands-and-management-commands&#34;&gt;Show commands and Management commands&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;  $ docker
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;docker-version&#34;&gt;Docker version :&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;  $ docker --version
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;show-info-like-number-of-containers&#34;&gt;Show info like number of containers&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;  $ docker info
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;commands-required-for-containers&#34;&gt;Commands required for Containers&lt;/h2&gt;

&lt;h4 id=&#34;command-to-run-a-container-in-foreground&#34;&gt;Command to run a container in foreground :&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;  $ docker container run -it -p 80:80 {image name}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Example : docker container run -it -p 80:80 nginx&lt;/p&gt;

&lt;h4 id=&#34;command-to-run-a-container-in-backround&#34;&gt;Command to run a container in backround :&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;  $ docker container run -d -p 80:80 {image name}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;short-hand-command&#34;&gt;Short hand command&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;  $ docker container run -d -p 80:80 {image name}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;naming-custom-names-to-container&#34;&gt;Naming custom names to container&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;  $ docker container run -p 80:80 --name {container name} {image name}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Example : docker container run -d -p 80:80 &amp;ndash;name nginx-server nginx&lt;/p&gt;

&lt;h3 id=&#34;purpose-of-run-in-command&#34;&gt;Purpose of &amp;ldquo;run&amp;rdquo; in command :&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;It actually looks for image in local cache.&lt;/li&gt;
&lt;li&gt;If image is not found, it looks into Docker Hub where default image repo may exist(its like github for docker images).&lt;/li&gt;
&lt;li&gt;It pulls it down from there and stores into local image cache.&lt;/li&gt;
&lt;li&gt;Starts in a new container.&lt;/li&gt;
&lt;li&gt;As we know syntax for port specification is HOST:CONTAINER port. So here we can access on port 80.&lt;/li&gt;
&lt;li&gt;We can also access it on any port by changing host port. For e.g. , if we want access on port 3000, then we need to write here 3000:80.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;commands-for-listing-containers&#34;&gt;Commands for listing containers&lt;/h4&gt;

&lt;p&gt;These two commands gives us running containers.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $ docker ps
    $ docker container ls
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This command will give us all containers(including those containers as well which are not running).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $ docker container ls -a
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;commands-to-stop-container&#34;&gt;Commands to stop container&lt;/h4&gt;

&lt;h5 id=&#34;stop-a-specific-container&#34;&gt;Stop a specific container&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;  $ docker container stop [ID]
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;stop-all-containers&#34;&gt;Stop all containers&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;  $ docker stop $(docker ps -aq)
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;remove-a-specific-container&#34;&gt;Remove a specific container&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;  $ docker container rm -f [ID]
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;remove-multiple-containers&#34;&gt;Remove multiple containers&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;  $ docker container rm [ID] [ID] [ID]
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;remove-all-containers&#34;&gt;Remove all containers&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;  $ docker rm $(docker ps -aq)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;get-logs-of-container&#34;&gt;Get logs of container&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;  $ docker container logs [NAME]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;list-processes-running-in-container&#34;&gt;List processes running in container&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;  $ docker container top [NAME]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;view-container-info&#34;&gt;View Container Info&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;  $ docker container inspect [NAME]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;performance-stats&#34;&gt;Performance stats&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;  $ docker container stats [NAME]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;commands-required-for-images&#34;&gt;Commands required for Images&lt;/h2&gt;

&lt;h5 id=&#34;list-images&#34;&gt;List images&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;  $ docker images
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;build-image&#34;&gt;Build Image&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;  $ docker image build -t [REPONAME] .
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;pull-image&#34;&gt;Pull Image&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;  $ docker pull [IMAGE]
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;remove-a-specific-image&#34;&gt;Remove a specific image&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;  $ docker image rm [IMAGE]
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;remove-all-images&#34;&gt;Remove all images&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;  $ docker rmi $(docker images -a -q)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;image-tagging-and-pushing-to-docker-hub&#34;&gt;Image tagging and pushing to docker hub&lt;/h4&gt;

&lt;p&gt;Tags are labels that point to an Image&lt;/p&gt;

&lt;h5 id=&#34;tagging-an-existing-image&#34;&gt;Tagging an Existing Image&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;  $ docker image tag {old name} {new tag name}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;upload-to-docker-hub&#34;&gt;Upload to docker hub&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;  $ docker image push {imageTag}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;note-if-pushing-operation-is-denied-do-login-in-docker-using&#34;&gt;Note : If pushing operation is denied, do login in docker using&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;    $ docker login
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;docker-networks&#34;&gt;Docker Networks&lt;/h2&gt;

&lt;h4 id=&#34;get-port&#34;&gt;Get Port&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;  $ docker container port [NAME]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;list-networks&#34;&gt;List Networks&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;  $ docker network ls
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;inspect-network&#34;&gt;Inspect Network&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt; $ docker network inspect [NETWORK_NAME]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;create-network&#34;&gt;Create network&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$ docker network create [NETWORK_NAME]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;create-container-on-network&#34;&gt;Create container on network&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$ docker container run -d --name [NAME] --network [NETWORK_NAME] [IMAGE_NAME]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;connect-existing-container-to-network&#34;&gt;Connect existing container to network&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$ docker network connect [NETWORK_NAME] [CONTAINER_NAME]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;disconnect-container-from-network&#34;&gt;Disconnect container from network&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$ docker network disconnect [NETWORK_NAME] [CONTAINER_NAME]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;detach-network-from-container&#34;&gt;Detach network from container&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$ docker network disconnect
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Scala Part-2</title>
      <link>http://sheenamnarula1993.github.io/post/scalaprojectstructure/</link>
      <pubDate>Thu, 20 Jun 2019 00:00:00 +0530</pubDate>
      
      <guid>http://sheenamnarula1993.github.io/post/scalaprojectstructure/</guid>
      <description>&lt;p&gt;.idea/— contains IntelliJ’s project specific settings files. According to JetBrains, normally there is no need to edit the contents of this folder.&lt;/p&gt;

&lt;p&gt;build.sbt — contains build definition of the project. For example, project name, project version, scalaVersion, libraryDependencies, etc. Note that this file is written in Scala.&lt;/p&gt;

&lt;p&gt;project/—because build.sbt is written in Scala, we need to build build.sbt. Therefore, this folder contains all the files needed for building build.sbt.&lt;/p&gt;

&lt;p&gt;project/build.properties — this file contains build definition of build.sbt. For example, it defines sbt version.&lt;/p&gt;

&lt;p&gt;project/target/— contains artifacts from building build.sbt.&lt;/p&gt;

&lt;p&gt;src/—this is where we put our source files. sbt uses the same directory structure as Maven for source files by default. Other directories in src/ will be ignored in build time.&lt;/p&gt;

&lt;p&gt;src/main/scala — contains main .scala files&lt;/p&gt;

&lt;p&gt;src/main/java — contains main .java files&lt;/p&gt;

&lt;p&gt;src/main/resources — contains main files other than .scala/.java files&lt;/p&gt;

&lt;p&gt;src/test/scala — contains test .scala files&lt;/p&gt;

&lt;p&gt;src/test/java — contains test .java files&lt;/p&gt;

&lt;p&gt;src/test/resources — contains test files other than .scala/.java files&lt;/p&gt;

&lt;p&gt;target/— contains artifacts from building the project&lt;/p&gt;

&lt;p&gt;println(&amp;ldquo;Hello World&amp;rdquo;)
Where should we chuck it?&lt;/p&gt;

&lt;p&gt;Normally when you run a Scala sbt project, it will use the main function as the entry point to run the project. So another question — where should we chuck the main function?&lt;/p&gt;

&lt;p&gt;Because sbt needs to call the main function from an object, the answer is that we write it in a Scala object like this:&lt;/p&gt;

&lt;p&gt;object HelloWorldMain {
def main(args: Array[String]): Unit = {
println(&amp;ldquo;Hello World&amp;rdquo;)
}
}
So, let’s create a package called com.helloworld (alternatively you can use your domain name in reverse order) in src/main/scala.&lt;/p&gt;

&lt;p&gt;Then right-click on the package and select New -&amp;gt; Scala Class. We will name the class HelloWorldMain. Before you click OK, remember to change Kind from Class to Object for the reason we mentioned earlier.&lt;/p&gt;

&lt;p&gt;You can add the code snippet we discussed earlier in the file.&lt;/p&gt;

&lt;p&gt;Build and Run the project
Now you should be able to see two green arrows next to your main function. Clicking either of them will build and run the project.&lt;/p&gt;

&lt;p&gt;Then you will see the “Hello World” text printed out in the Run tool window in Intellij.&lt;/p&gt;

&lt;p&gt;And the build artifact can be found in target/scala-2.12/classes.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Scala Part-1</title>
      <link>http://sheenamnarula1993.github.io/post/scala/</link>
      <pubDate>Wed, 19 Jun 2019 00:00:00 +0530</pubDate>
      
      <guid>http://sheenamnarula1993.github.io/post/scala/</guid>
      <description>&lt;p&gt;SBT is a popular tool for compiling, running, and testing Scala projects of any size. Using a build tool such as sbt (or Maven/Gradle) becomes essential once you create projects with dependencies or more than one code file.&lt;/p&gt;

&lt;p&gt;When you write small programs that consist of only one, or just two or three source files, then it&amp;rsquo;s easy enough to compile those source files by typing scalac MyProgram.scala in the command line.&lt;/p&gt;

&lt;p&gt;But when you start working on a bigger project with dozens or maybe even hundreds of source files, then it becomes too tedious to compile all those source files manually. You will then want to use a build tool to manage compiling all those source files.&lt;/p&gt;

&lt;p&gt;sbt is such a tool. There are other tools too, some other well-known build tools that come from the Java world are Ant and Maven.&lt;/p&gt;

&lt;p&gt;How it works is that you create a project file that describes what your project looks like; when you use sbt, this file will be called build.sbt. That file lists all the source files your project consists of, along with other information about your project. Sbt will read the file and then it knows what to do to compile the complete project.&lt;/p&gt;

&lt;p&gt;Besides managing your project, some build tools, including sbt, can automatically manage dependencies for you. This means that if you need to use some libraries written by others, sbt can automatically download the right versions of those libraries and include them in your project for you.&lt;/p&gt;

&lt;p&gt;Let’s look at how to use published libraries to add extra functionality to our apps.&lt;/p&gt;

&lt;p&gt;Open up build.sbt and add the following line:
libraryDependencies += &amp;ldquo;org.scala-lang.modules&amp;rdquo; %% &amp;ldquo;scala-parser-combinators&amp;rdquo; % &amp;ldquo;1.1.0&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Here, libraryDependencies is a set of dependencies, and by using +=, we’re adding the scala-parser-combinators dependency to the set of dependencies that sbt will go and fetch when it starts up. Now, in any Scala file, you can import classes, objects, etc, from scala-parser-combinators with a regular import.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Cold War</title>
      <link>http://sheenamnarula1993.github.io/post/cold-war/</link>
      <pubDate>Tue, 04 Jun 2019 00:00:00 +0530</pubDate>
      
      <guid>http://sheenamnarula1993.github.io/post/cold-war/</guid>
      <description>

&lt;p&gt;The cold war was a state of geopolitical tension after second world war between Eastern Bloc(The Soviet Union and its satellite states) and Western Bloc(the United States and its NATO Alies)&lt;/p&gt;

&lt;p&gt;Cold war era - 1947 to &lt;sup&gt;1989&lt;/sup&gt;&amp;frasl;&lt;sub&gt;1991&lt;/sub&gt;.
But actually it doesnot have any fix date.&lt;/p&gt;

&lt;h3 id=&#34;why-is-it-called-cold-war&#34;&gt;Why is it called cold war :&lt;/h3&gt;

&lt;p&gt;No direct combat or fight between USSR + Allies and US + allies but there were proxy wars like Korean War,Vietnam War and Afghanistan war.&lt;/p&gt;

&lt;p&gt;Proxy wars are like if there are two super powers A(US) and B(Soviet Union), and war is going on between C and D, then A is supporting C and B is supporting D. In this way, they are showing their power to each other indirectly.&lt;/p&gt;

&lt;h3 id=&#34;characteristics-of-cold-war&#34;&gt;Characteristics of Cold war :&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Ideological differences(US is Capitalist and Soviet is Communist)&lt;/li&gt;
&lt;li&gt;Atmosphere of political distrust(Each power was thinking that other power wanted to invade in its region)&lt;/li&gt;
&lt;li&gt;Brinkmanship(means taking world to the edge of war and then take a step back)&lt;/li&gt;
&lt;li&gt;Psychological warfare(both powers thought that the other power was evil)&lt;/li&gt;
&lt;li&gt;Arms Race(High military spending)&lt;/li&gt;
&lt;li&gt;Espionage(to spy other power&amp;rsquo;s activities)&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;nuclear-capability&#34;&gt;Nuclear Capability :&lt;/h4&gt;

&lt;p&gt;Both powers could destroy earth many times over because of their nuclear capabilities.This was the main reason due to which cold war never turned out to be a hot war.&lt;/p&gt;

&lt;h3 id=&#34;the-beginnings-of-cold-war&#34;&gt;The Beginnings of Cold war :&lt;/h3&gt;

&lt;p&gt;Many people say that the cold war was started with the Russian Revolution in which there was a civil war between Reds(Communists) and Whites.Reds won the war and USSR was established in 1922. USA, UK and France supported Whites at that time.So there were obvious frictions between communists and these nations. US didn&amp;rsquo;t give the recognition to USSR initially but in 1933 Diplomatic Relations between USSR and US got established.&lt;/p&gt;

&lt;h5 id=&#34;reason-behind-non-recoginition&#34;&gt;Reason behind Non-Recoginition :&lt;/h5&gt;

&lt;p&gt;On December 6, 1917, the U.S. Government broke off diplomatic relations with Russia, shortly after the Bolshevik Party seized power from the Tsarist regime after the “October Revolution.” President Woodrow Wilson decided to withhold recognition at that time because the new Bolshevik government had refused to honor prior debts to the United States incurred by the Tsarist government, ignored pre-existing treaty agreements with other nations, and seized American property in Russia following the October Revolution. The Bolsheviks had also concluded a separate peace with Germany at Brest-Litovsk in March 1918, ending Russian involvement in World War I. Despite extensive commercial links between the United States and the Soviet Union throughout the 1920s, Wilson’s successors upheld his policy of not recognizing the Soviet Union.&lt;/p&gt;

&lt;p&gt;After world war II in 1945, USSR tried to influence throughout central and eastern Europe as a buffer against Germany because in WWI and WWII, Germany attacked Russia and USSR totally understood that in future this could happen again. So to avoid this situation, it thought to create buffer which could be done through eastern and central Europe.
On the other side, USA was trying to influence France,West Germany,Japan and Korea and tried to set up Capitalism supporting leaders in these countries.
So in this type of atmosphere, Wintson Churchill,the Prime Minister of England, gave a statement &amp;ldquo;An Iron Curtain has descended over the continent&amp;rdquo;.The term Iron Curtain refers to the following picture of map :&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sheenamnarula1993.github.io/img/iron-curtain.jpg&#34; alt=&#34;Example image&#34; /&gt;&lt;/p&gt;

&lt;h5 id=&#34;the-iron-curtain&#34;&gt;The Iron Curtain :&lt;/h5&gt;

&lt;p&gt;It was the name for the non-physical boundary dividing Europe into two separate areas from the end of World War II in 1945 until the end of the Cold War in 1991. The term symbolizes the efforts by the Soviet Union to block itself and its satellite states from open contact with the West and its allied states. On the east side of the Iron Curtain were the countries that were connected to or influenced by the Soviet Union, while on the west side were the countries that were allied to the United States or nominally neutral. Separate international economic and military alliances were developed on each side of the Iron Curtain.
(West Germany was captured by America,France and Britain and East Germany was occupied by Soviet Union)&lt;/p&gt;

&lt;p&gt;Against this Iron Curtain, America opted for some policies.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Containment Policy: This policy is about stopping further expansion of Communism.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Marshall Plan for Resconstruction: America provided economic help to the countries which suffered a lot of destruction in war. In this way, according to marshall plan, it tried to establish capitalism in those countries.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Truman Doctrine,1947: According to this policy, US said that it would support every country which was against communism.It would provide economic,political and even military help to the countries which were against communism.That was why South Korea was supported by US in Korean War.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;US also propped up many communist regimes throughout the world.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;incidents-of-cold-war&#34;&gt;Incidents of Cold War :&lt;/h3&gt;

&lt;h4 id=&#34;berlin-blockade-1948&#34;&gt;Berlin Blockade (1948) :&lt;/h4&gt;

&lt;p&gt;At that time, West Berlin was under USA and East Berlin was under USSR. The USSR wanted to control entire Berlin.As Berlin was surrounded by USSR, so it stopped the supply route to west Berlin.But USA UK air dropped supplies to break the blockade to maintain west Berlin.For around one year, with the help of two lakh planes, they maintained west Berlin by providing food, fuel etc.So at last, USSR dropped the blockade because it was not successful as air dropped supplies were quite helpful in providing stuff to people.&lt;/p&gt;

&lt;p&gt;In 1949, Germany was officially divided into two parts East Germany(under USSR) and West Germany(under US)&lt;/p&gt;

&lt;h4 id=&#34;1949-events&#34;&gt;1949 Events:&lt;/h4&gt;

&lt;h5 id=&#34;the-north-atlantic-treaty-organization-nato&#34;&gt;THE NORTH ATLANTIC TREATY ORGANIZATION (NATO)&lt;/h5&gt;

&lt;p&gt;Berlin blockade happened in 1948 because of which America was quite aware of the fact that it has to do something about USSR. So USA and some other countries formed NATO. A breif description of NATO is here :&lt;/p&gt;

&lt;p&gt;The Cold War was in full swing, as the Soviet Union was rising to power, capturing satellite countries. Using their strong dynamic forces, the Soviet Union captured surrounding countries first to help protect them from any invasion. This tactic was used to imprison civilians and force them to join the Soviet military. As their armed forces greatly increased in numbers, other countries and nations feared that the Soviet Union would expand their control and take over other countries.&lt;/p&gt;

&lt;p&gt;In response to this, the North Atlantic Treaty Organization was formed. NATO is a formal alliance between the territories of North American and Europe. From its inception, its main purpose was to defend each other from the possibility of communist Soviet Union taking control of their nation. Many powerful countries joined NATO by the signing of the official document in 1949: Belgium, Great Britain, Italy, Iceland, Luxembourg, United States, Canada, Netherlands, Denmark, Norway and Portugal. In 1950, General Dwight D. Eisenhower was nominated and appointed as the first supreme allied commander. Since Eisenhower was from the United States, this allowed the U.S. to be a strong force in the organization. West Germany, Turkey and Greece joined by 1955.&lt;/p&gt;

&lt;p&gt;Today, NATO is ideally an outstanding way for the twenty-six different countries and nations to come together. As an organization, the leaders meet with one another to make decisions about security issues and defensive issues against allied attacks. Also, NATO has armed forces, made up of civilians of all twenty-six countries. They defend and aid countries in crisis, just like Darfur. The North Atlantic Council is made up on knowledgeable political and military leaders represented by each country. This council comes to a consensus on making important decisions on what political and military tactics to use, for daily activity.&lt;/p&gt;

&lt;h4 id=&#34;result-of-civil-war-in-china&#34;&gt;Result of civil war in CHINA :&lt;/h4&gt;

&lt;p&gt;In China Civil War, Communist won and China fell under Communist power except Taiwan.&lt;/p&gt;

&lt;h4 id=&#34;nuclear-weapon-by-ussr&#34;&gt;Nuclear Weapon by USSR :&lt;/h4&gt;

&lt;p&gt;In 1949, USSR tested its first nuclear weapon. USA was already having nuclear weapon as we all know about Hiroshima and Nagasaki incident.USA always convinced countries to be with it by showing its nuclear power but now USSR was also having nuclear weapons.This was the main reason why this cold war did not turn out to be hot war.&lt;/p&gt;

&lt;p&gt;Many communist govts were established in east and central Europe&lt;/p&gt;

&lt;p&gt;By 1950, it was quite clear that the two sides were at war without open conflict and basically it was an ideological war between communism and capitalism.&lt;/p&gt;

&lt;h4 id=&#34;nuclear-angle&#34;&gt;Nuclear Angle :&lt;/h4&gt;

&lt;p&gt;First time in human history,humans were having that power which could destroy human race and earth like 50 times.
Initially, nuclear bombs needed to be carried in planes to attack like in case of Hiroshima and Nagasaki, America sent its planes carrying nuclear bombs to attack.But during this cold war,BALLISTIC MISSILES were developed which could carry nuclear bombs over thousands of killometres.ICBM(Inter Continent Ballistic Missiles) assured mutual assured destrucion which is termed as MAD, means if USA attacked USSR, then in return USSR could also attack USA and both had to suffer same losses.&lt;/p&gt;

&lt;h4 id=&#34;korean-war-1950-1953&#34;&gt;Korean war(1950-1953) :&lt;/h4&gt;

&lt;p&gt;It was a first proxy war between these two nations.After world war II, North Korea was under USSR and South Korea was under USA.In 1950,there was a war between North Korea and South Korea.
USSR and PRC backed North Korea attacked South Korea.
USA and allies came to aid south and a stalemate ensued.(stalemate means no party won and border was still the same).
After this, a Cease fire agreement was signed between North and South Korea.&lt;/p&gt;

&lt;h4 id=&#34;domino-theory&#34;&gt;Domino Theory :&lt;/h4&gt;

&lt;p&gt;After Korean war, domino theory came into being.
&lt;img src=&#34;http://sheenamnarula1993.github.io/img/domino-theory.jpeg&#34; alt=&#34;Example image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;According to this theory, communism is like a domino.If one country fell in a domino, then due to its effect other countries would also fall.Like in 1950, communism was established in China,north Vietnam,Korea,Laos and USA was afraid of that communism could also be established in Thailand, Malaysia, India, Burma etc.So USA thought to stop the domino effect, they needed to start a proxy war and Vietnam war was the result of this thought.&lt;/p&gt;

&lt;h3 id=&#34;1950s-escalation&#34;&gt;1950s Escalation :&lt;/h3&gt;

&lt;p&gt;In decade of 1950, cold war was at its height.&lt;/p&gt;

&lt;h5 id=&#34;1953&#34;&gt;1953 :&lt;/h5&gt;

&lt;p&gt;Stalin died and a new leader for USSR was Nikita Khrushchev and in USA elections, Eisenhower was chosen by public as a new President.&lt;/p&gt;

&lt;h5 id=&#34;1955&#34;&gt;1955 :&lt;/h5&gt;

&lt;p&gt;USSR signed a WARSAW pact with communist countries agains NATO.&lt;/p&gt;

&lt;p&gt;At this time, along with arms race, Space race also began.First satellite and first person to space was sent by Soviet Union but in moon race, America won.&lt;/p&gt;

&lt;p&gt;In 1950s, USSR was supporting communist rebels in Latin America,Asia and Africa.&lt;/p&gt;

&lt;p&gt;USA showed a different face to world in 1950s. Just to stop communism, it also supported dictatorship in many countries like Iran,Chile,Brazil,Dominica etc.For this support, USA&amp;rsquo;s reputation got affected because USA was a champion of democracy but it supported dictatorship to stop communism.&lt;/p&gt;

&lt;h5 id=&#34;1956-hungarian-revolution&#34;&gt;1956 Hungarian Revolution :&lt;/h5&gt;

&lt;p&gt;Hungarian Revolution crushed by soviets by sending military.It was the first time, USSR sent its army in other country to supress revolution.&lt;/p&gt;

&lt;h5 id=&#34;1956-suez-crisis&#34;&gt;1956 Suez crisis :&lt;/h5&gt;

&lt;p&gt;There was a Suez canal which existed in Egypt but was under England because it built this canal. Egypt govt. wanted to nationalize it. So at that time, England, France and Isryl attacked on Egypt but at the mean time USSR participated and backed Egypt.USSR threatened that it could be a nuclear war.In response to this threat, USA pressurized England, France and Isryl to take back their armies from Egypt.&lt;/p&gt;

&lt;h5 id=&#34;1950s-war-in-indochina-raged-on&#34;&gt;1950s War in Indochina raged on :&lt;/h5&gt;

&lt;p&gt;War was going on in France colonies and Communist governments supported the local people there against the France government.South Vietnam was supported by America.&lt;/p&gt;

&lt;h3 id=&#34;1960s&#34;&gt;1960s&lt;/h3&gt;

&lt;h5 id=&#34;three-world-order&#34;&gt;Three World Order :&lt;/h5&gt;

&lt;p&gt;When there were two groups in the world, a third group also came into being which was of Non-Aligned countries whose leaders were India, Egypt, Indonesia and Yugoslavia.Non-aligned movement came into being in 1961.According to this, the countries being a part of this movement were neither supporting US nor USSR.&lt;/p&gt;

&lt;p&gt;With this a terminology,THREE WORLD ORDER came into being. According to this First World was Capitalist Countries(Western Bloc),Second World was Communism(Eastern Bloc) and Third World included Non-aligned countries.&lt;/p&gt;

&lt;h5 id=&#34;1960-u2-plane-incident&#34;&gt;1960 U2 plane incident :&lt;/h5&gt;

&lt;p&gt;USA sent a plane over USSR to spy.That plane got crashed and pilot was arrested by USSR.There was a summit going to be held in Paris to find a solution of cold war.Due to this incident, USSR was annoyed and that summit got failed.&lt;/p&gt;

&lt;h5 id=&#34;1961&#34;&gt;1961 :&lt;/h5&gt;

&lt;p&gt;Berlin wall was constructed by East Germany to stop people who were moving secretly to West Germany because they did not want to live under communist government.&lt;/p&gt;

&lt;h5 id=&#34;1962-cuban-crisis&#34;&gt;1962 Cuban crisis :&lt;/h5&gt;

&lt;p&gt;Cuban missile crisis, (October 1962), major confrontation that brought the United States and the Soviet Union close to war over the presence of Soviet nuclear-armed missiles in Cuba.&lt;/p&gt;

&lt;p&gt;Having promised in May 1960 to defend Cuba with Soviet arms, the Soviet premier Nikita Khrushchev assumed that the United States would take no steps to prevent the installation of Soviet medium- and intermediate-range ballistic missiles in Cuba. Such missiles could hit much of the eastern United States within a few minutes if launched from Cuba. The United States learned in July 1962 that the Soviet Union had begun missile shipments to Cuba. By August 29 new military construction and the presence of Soviet technicians had been reported by U.S. U-2 spy planes flying over the island, and on October 14 the presence of a ballistic missile on a launching site was reported.&lt;/p&gt;

&lt;p&gt;After carefully considering the alternatives of an immediate U.S. invasion of Cuba (or air strikes of the missile sites), a blockade of the island, or further diplomatic maneuvers, Pres. John F. Kennedy decided to place a naval “quarantine,” or blockade, on Cuba to prevent further Soviet shipments of missiles. Kennedy announced the quarantine on October 22 and warned that U.S. forces would seize “offensive weapons and associated material” that Soviet vessels might attempt to deliver to Cuba. During the following days, Soviet ships bound for Cuba altered course away from the quarantined zone. As the two superpowers hovered close to the brink of nuclear war, messages were exchanged between Kennedy and Khrushchev amidst extreme tension on both sides. On October 28 Khrushchev capitulated, informing Kennedy that work on the missile sites would be halted and that the missiles already in Cuba would be returned to the Soviet Union. In return, Kennedy committed the United States never to invade Cuba. Kennedy also secretly promised to withdraw the nuclear-armed missiles that the United States had stationed in Turkey in previous years. In the following weeks both superpowers began fulfilling their promises, and the crisis was over by late November. Cuba’s communist leader, Fidel Castro, was infuriated by the Soviets’ retreat in the face of the U.S. ultimatum but was powerless to act.&lt;/p&gt;

&lt;h5 id=&#34;1962-sano-soviet-separation&#34;&gt;1962 Sano Soviet separation :&lt;/h5&gt;

&lt;p&gt;China got separated from USSR saying that ideology behind the communist government of USSR is different from the ideology it is following being a communist country.
But both continued to support gorillas in Vietnam war.&lt;/p&gt;

&lt;h5 id=&#34;1968-praque-spring-reforms-crushed-by-ussr&#34;&gt;1968- Praque spring reforms crushed by USSR.&lt;/h5&gt;

&lt;p&gt;Vietnam war carried on at a brutal scale.Finally,North Vietnam won backed by USSR won in 1975.&lt;/p&gt;

&lt;h3 id=&#34;1970s-de-escalation&#34;&gt;1970s De-Escalation&lt;/h3&gt;

&lt;h5 id=&#34;1972&#34;&gt;1972 :&lt;/h5&gt;

&lt;p&gt;US and China established diplomatic relations, trade relations and America gave recognition to China&lt;/p&gt;

&lt;h5 id=&#34;1973-detente-cooperation-between-usa-and-ussr&#34;&gt;1973- Detente(Cooperation) between USA and USSR :&lt;/h5&gt;

&lt;p&gt;Under this, SALT(Strategic Arms Limitation Talks) was successful in which two topics were discussed :
-Reducing nuclear missiles
-Reducing anti ballistic missiles&lt;/p&gt;

&lt;p&gt;After SALT, tension between two nations was significanly reduced. But in 1979, USSR send troops to Afghanistan to help newly formed Communist govt. which annoyed USA as USA thought that USSR was following its old policy of expansion. So in return, USA supported Mujaheedin(rebels in Afghanistan) against USSR.So this again ended cooperation between USSR and USA.&lt;/p&gt;

&lt;h3 id=&#34;1980s&#34;&gt;1980s&lt;/h3&gt;

&lt;h5 id=&#34;1979&#34;&gt;1979 :&lt;/h5&gt;

&lt;p&gt;In 1979, due to end in cooperation between USSR and USA, USA boycotted olympics held in Moscow in 1980 and USSR boycotted olympics held in Los Angeles in 1984.&lt;/p&gt;

&lt;h5 id=&#34;1981&#34;&gt;1981 :&lt;/h5&gt;

&lt;p&gt;In 1981,Ronald Regan became the President of USA and he spent on military immenselt which could not be competed by USSR due to it failing economy.&lt;/p&gt;

&lt;p&gt;USSR was shocked about USA&amp;rsquo;s Strategic Defensive Initiative plan under which satellites were supposed to be equipped with nuclear missiles.This was named as STAR WARS by people.But later this plan was not finalized by USA.&lt;/p&gt;

&lt;h5 id=&#34;1983&#34;&gt;1983 :&lt;/h5&gt;

&lt;p&gt;Large NATO military exercise made USSR to think about USA was gonna attack USSR and brought the world on brink if nuclear annihilation.&lt;/p&gt;

&lt;p&gt;South Korean civilian plane shot down by USSR giving excuse that this plane was sent to spy in USSR.&lt;/p&gt;

&lt;p&gt;1985- Mikhail Gorbachev becomes Gen. Sec.of Communist party in USSR. After his arriavl, cold war started to end.&lt;/p&gt;

&lt;h3 id=&#34;the-end-of-cold-war&#34;&gt;The end of Cold War&lt;/h3&gt;

&lt;p&gt;Main reason- reforms brought by Gorbachev and economy of USSR.&lt;/p&gt;

&lt;p&gt;The communist economy simply could not keep up with high growth rates of capitalist ones because of non-existence of privatization of industries.To increase the economic growth, Gorbachev brougt reforms which were :&lt;/p&gt;

&lt;p&gt;Glasnost : It included:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Openness&lt;/li&gt;
&lt;li&gt;Freedom of speech&lt;/li&gt;
&lt;li&gt;Easing of media censorship(now news from America and other parts of the world could be seen by people)&lt;/li&gt;
&lt;li&gt;Earlier records declassified by RTI&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Perestroika
Restructuring/Reformation was done under which Soviet Political and Economic structure was improved.&lt;/p&gt;

&lt;p&gt;The most important part of Political reforms was Elections.Elections was not mean that there were different parties but it was selection of communist party members by people, initially which was done by higher authorities of communist party.&lt;/p&gt;

&lt;p&gt;Foreign Business and privately owned business were allowed under economic reforms.&lt;/p&gt;

&lt;h3 id=&#34;demand-of-independence&#34;&gt;Demand of Independence&lt;/h3&gt;

&lt;p&gt;After these reforms,all over Europe(the satellite states or warsaw states), started to demand independence and change in communist government.&lt;/p&gt;

&lt;p&gt;In 1989, Peaceful revolutions were made to get rid of communism in most countries except Romania where the leader,Nicolae Ceaușescu was shot dead by people.&lt;/p&gt;

&lt;p&gt;Unlike in Hungary and Prague, this time there was no military suppression by Soviet Union to crush these revolutions.&lt;/p&gt;

&lt;p&gt;Berlin wall fell and East and West Germany got united.&lt;/p&gt;

&lt;p&gt;In response to Gorbachev&amp;rsquo;s reforms, USA started talks for de escalation,limiting nuclear weapoins and removal of army from Afghanistan.&lt;/p&gt;

&lt;p&gt;In Dec. 1991, USSR is dissolved due to internal revolution and all 15 sub national soviets form their soverign countries.&lt;/p&gt;

&lt;h3 id=&#34;aftermath-of-cold-war&#34;&gt;Aftermath of Cold War&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Unipolar world- USA the only Superpower&lt;/li&gt;
&lt;li&gt;Russian Economy suffered badly&lt;/li&gt;
&lt;li&gt;Conflicts in Balkan states - Yugoslavia(1992 - 97(approx.))&lt;/li&gt;
&lt;li&gt;The threat of nuclear war is still there but very much less than during the span of cold war.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Basic Electronics Part-1</title>
      <link>http://sheenamnarula1993.github.io/post/basic-electronics/</link>
      <pubDate>Sat, 01 Jun 2019 00:00:00 +0530</pubDate>
      
      <guid>http://sheenamnarula1993.github.io/post/basic-electronics/</guid>
      <description>

&lt;h4 id=&#34;no-definitions-only-understanding&#34;&gt;(NO DEFINITIONS ,ONLY UNDERSTANDING)&lt;/h4&gt;

&lt;p&gt;We all have heard the term, Electricity.&lt;/p&gt;

&lt;p&gt;But when we need to explain this term, we can see the working fan, glowing tube and yes, after plugging in phone&amp;rsquo;s charger, simply we can see the increasing percentage sign.
&lt;img src=&#34;http://sheenamnarula1993.github.io/img/electricity.jpg&#34; alt=&#34;Example image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Have you ever tried to explore, what is this Electricity ?
What does this contain due to which phone&amp;rsquo;s battery is charging and i am able to use it in daily life and yes, what is this term charging means ?&lt;/p&gt;

&lt;p&gt;So for this, we need to know about the term &amp;ldquo;Charge&amp;rdquo;.&lt;/p&gt;

&lt;h4 id=&#34;charge&#34;&gt;Charge :&lt;/h4&gt;

&lt;p&gt;We all at one point must have observered a very common phenomena of rubbing a silk cloth with glass rod or when you comb your hair or take off your hat on a cold, dry day, your hair stand on the end.&lt;/p&gt;

&lt;p&gt;So what is the reason behind this ?&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s take an example of silk cloth and glass rod. Take two pair of glass and silk cloth. When you rub each glass rod with its respective cloth, you will observe that after rubbing, one glass rod will repel another glass rod and same is the case with silk cloth i.e. one silk cloth will repel another silk cloth.&lt;/p&gt;

&lt;p&gt;But glass rods will start attracting their respective silk clothes.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sheenamnarula1993.github.io/img/glass-silk-attraction.webp&#34; alt=&#34;Example image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;When this phenomena was observed, in old times, it was said that there were inivisible &amp;ldquo;fluids&amp;rdquo; which were flowing from one object to another and were able to effect a physical force over a distance.&lt;/p&gt;

&lt;p&gt;Later, Charles Dufay was one of the early experimenters who demonstrated that there were definitely two different types of changes wrought by rubbing certain pairs of objects together. The fact that there was more than one type of change manifested in these materials was evident by the fact that there were two types of forces produced: attraction and repulsion. The hypothetical fluid transfer became known as a &amp;ldquo;Charge&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Later,one researcher, Benjamin Franklin,came to the conclusion that the two types of invisible fluids were not actually two, it was only one type of fluid that is tranferred when two materials are rubbed together, and that the two different “charges” were nothing more than either an excess or a deficiency of that one fluid.After experimenting with silk cloth and glass rod, he observed that glass rod removed some of invisible fluid from silk cloth, which created deficiency of fluid in silk cloth and attraction force is because silk cloth wanted to regain its fluid and trying to achieve its neutral state.&lt;/p&gt;

&lt;p&gt;So following Franklin’s speculation of the silk cloth rubbing something off of the glass rod, the type of charge that was associated with rubbed silk cloth became known as “negative” (because it was supposed to have a deficiency of fluid) while the type of charge associated with the rubbing glass rod became known as “positive” (because it was supposed to have an excess of fluid).&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sheenamnarula1993.github.io/img/glass-silk-rod.jpeg&#34; alt=&#34;Example image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;As further experiments proceeded and the concept of atom came into light, it was discovered much later that this “fluid” was actually composed of extremely small bits of matter called &amp;ldquo;Electrons&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;You must be wondering about the term &amp;ldquo;Electrons&amp;rdquo;.Let&amp;rsquo;s have a very small overview of that as well.&lt;/p&gt;

&lt;p&gt;Till now,that all objects are composed of extremely small “building-blocks” known as atoms and that these atoms are in turn composed of smaller components known as particles. The three fundamental particles comprising most atoms are called protons, neutrons and electrons. Atoms are far too small to be seen, but if we could look at one, it might appear something like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://sheenamnarula1993.github.io/img/atoms.webp&#34; alt=&#34;Example image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;In this image, the structure of atom can be observed. Here protons and neutrons are tightly coupled with each other forming nucleus, but electrons are loosely coupled due to a lot of empty space between nucleus and electrons.&lt;/p&gt;

&lt;p&gt;Note: protons give the unique identity to atom.If we can remove proton from atom, we can change one element to another.&lt;/p&gt;

&lt;p&gt;As electrons have significantly more freedom to move around in an atom than either protons or neutrons. In fact, they can be knocked out of their respective positions (even leaving the atom entirely!) by far less energy than what it takes to dislodge particles in the nucleus.
(Like in case of silk and glass rod, electrons from glass rod got knocked out by silk cloth)
&lt;img src=&#34;http://sheenamnarula1993.github.io/img/before-rubbing.jpeg&#34; alt=&#34;Example image&#34; /&gt;
&lt;img src=&#34;http://sheenamnarula1993.github.io/img/after-rubbing.jpg&#34; alt=&#34;Example image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;If this happens, the atom still retains its chemical identity, but an important imbalance occurs. Electrons and protons are unique in the fact that they are attracted to one another over a distance. It is this attraction over distance which causes the attraction between rubbed objects, where electrons are moved away from their original atoms to reside around atoms of another object.&lt;/p&gt;

&lt;p&gt;Electrons tend to repel other electrons over a distance, as do protons with other protons.&lt;/p&gt;

&lt;p&gt;Now due to lack of electrons,effective force beacuse of protons is more and force of attraction comes into play as a result of trying to gain the former balance.On other side,the materials which already have electrons in excess amount repel each other.&lt;/p&gt;

&lt;p&gt;The only reason protons bind together in the nucleus of an atom is because of a much stronger force called the strong nuclear force which has effect only under very short distances.&lt;/p&gt;

&lt;p&gt;Because of this attraction/repulsion behavior between individual particles, electrons and protons are said to have opposite electric charges. That is, each electron has a negative charge, and each proton a positive charge. In equal numbers within an atom, they counteract each other’s presence so that the net charge within the atom is zero. This is why the picture of a carbon atom has six electrons: to balance out the electric charge of the six protons in the nucleus. If electrons leave or extra electrons arrive, the atom’s net electric charge will be imbalanced, leaving the atom “charged” as a whole, causing it to interact with charged particles and other charged atoms nearby.&lt;/p&gt;

&lt;h3 id=&#34;static-electricity&#34;&gt;Static Electricity&lt;/h3&gt;

&lt;p&gt;The result of an imbalance of this “fluid” (electrons) between objects is called static electricity. It is called “static” because the displaced electrons tend to remain stationary after being moved from one insulating material to another.&lt;/p&gt;

&lt;p&gt;An object whose atoms have received a surplus of electrons is said to be negatively charged, while an object whose atoms are lacking electrons is said to be positively charged.&lt;/p&gt;

&lt;p&gt;Michael Faraday proved (1832) that static electricity was the same as that produced by a battery or a generator.&lt;/p&gt;

&lt;p&gt;Flowing electrons actually called electricity but how these electrons flow and what makes these to flow, is covered in second part of basic electronics.&lt;/p&gt;

&lt;h1 id=&#34;summary&#34;&gt;Summary:&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;Electricity comprises of electrons which flow from one object to another when two objects are rubbed together.&lt;/li&gt;
&lt;li&gt;Object having surplus of electrons is negatively charged and object which is lacking electrons is positively charged.(This charge convention is quite opposite to its explanation, but by the time truth got revealed, Franklin&amp;rsquo;s nomenclature was well established and it was not changed).&lt;/li&gt;
&lt;li&gt;After moving from one object to another, electrons are stationary at those places and gives us static electricity like a battery(cell).&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>http://sheenamnarula1993.github.io/post/containerization-vs-vm/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://sheenamnarula1993.github.io/post/containerization-vs-vm/</guid>
      <description></description>
    </item>
    
    <item>
      <title>KUBERNETES</title>
      <link>http://sheenamnarula1993.github.io/post/kubernetes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://sheenamnarula1993.github.io/post/kubernetes/</guid>
      <description>

&lt;h2 id=&#34;kubernetes-vocab&#34;&gt;Kubernetes Vocab&lt;/h2&gt;

&lt;h3 id=&#34;node&#34;&gt;Node :&lt;/h3&gt;

&lt;p&gt;It is an instance of computer which is also known as worker nodes.&lt;/p&gt;

&lt;h3 id=&#34;pods&#34;&gt;Pods :&lt;/h3&gt;

&lt;p&gt;It is a smallest unit of kubernetes that we can deploy on kubernets cluster.It contain container&amp;rsquo;s image.
Bascially a pod is a collection of more than one conatiners which are supposed run on one host logically.&lt;/p&gt;

&lt;p&gt;When a pod is created, an ip address is assigned to it.When a worker node dies, replica of that pod is created but with different ip address and different volumes. That means everything related to pod lifecycle dies with that pod.(stable ip address concept)&lt;/p&gt;

&lt;h3 id=&#34;services&#34;&gt;Services :&lt;/h3&gt;

&lt;p&gt;Services are the end points that export ports to outside world and map the ports to pods.&lt;/p&gt;

&lt;h3 id=&#34;deployment&#34;&gt;Deployment :&lt;/h3&gt;

&lt;p&gt;It represents a set of multiple identical pods.Deployments run multiple instances or replicas of your application.It ensures the availability of one or more instances of app to serve user requests.Deployments are managed by kubernetes deployment controller.
Deployments use a Pod template, which contains a specification for its Pods. The Pod specification determines how each Pod should look like: what applications should run inside its containers, which volumes the Pods should mount, its labels, and more.&lt;/p&gt;

&lt;p&gt;When a Deployment&amp;rsquo;s Pod template is changed, new Pods are automatically created one at a time.&lt;/p&gt;

&lt;h3 id=&#34;installation-of-kubernetes&#34;&gt;Installation of kubernetes :&lt;/h3&gt;

&lt;p&gt;Let us install Minikube to run single-node kubernetes cluster in a virtual machine on your personal computer to work locally and kubectl as command line interface of kubernetes.&lt;/p&gt;

&lt;p&gt;Let us check first whether virtualization is supported on Linux. For this,run the following command and verify that the output is non-empty:
egrep &amp;ndash;color &amp;lsquo;vmx|svm&amp;rsquo; /proc/cpuinfo&lt;/p&gt;

&lt;h2 id=&#34;install-kubectl-link-for-installation&#34;&gt;Install kubectl : Link for installation&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://kubernetes.io/docs/tasks/tools/install-kubectl/#install-kubectl-on-linux&#34; target=&#34;_blank&#34;&gt;https://kubernetes.io/docs/tasks/tools/install-kubectl/#install-kubectl-on-linux&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;for-ubuntu-here-are-the-commands-to-install-kubectl&#34;&gt;For ubuntu, here are the commands to install kubectl :&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;  sudo apt-get update &amp;amp;&amp;amp; sudo apt-get install -y apt-transport-https
  curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add -
  echo &amp;quot;deb https://apt.kubernetes.io/ kubernetes-xenial main&amp;quot; | sudo tee -a /etc/apt/sources.list.d/kubernetes.list
  sudo apt-get update
  sudo apt-get install -y kubectl
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;install-minikube&#34;&gt;Install Minikube :&lt;/h2&gt;

&lt;h3 id=&#34;link-for-installation-https-kubernetes-io-docs-tasks-tools-install-minikube&#34;&gt;Link for Installation : &lt;a href=&#34;https://kubernetes.io/docs/tasks/tools/install-minikube/&#34; target=&#34;_blank&#34;&gt;https://kubernetes.io/docs/tasks/tools/install-minikube/&lt;/a&gt;&lt;/h3&gt;

&lt;h1 id=&#34;architecture-explanation-of-kubernetes&#34;&gt;Architecture explanation of kubernetes :&lt;/h1&gt;

&lt;h3 id=&#34;kubernetes-master-components-etcd-api-server-controller-manager-and-scheduler&#34;&gt;Kubernetes Master Components: Etcd, API Server, Controller Manager, and Scheduler :&lt;/h3&gt;

&lt;p&gt;Kubernetes master is considered as the brain of kubernetes cluster. It run Etcd, Scheduler, Controller Manager and Api Server inside it.Lets discuss there components briefly so that working on kubernetes should not appear to be strange and knowing components of kubernetes master will help us in a significant way in creating a working image of kubernetes master.&lt;/p&gt;

&lt;h4 id=&#34;etcd&#34;&gt;Etcd :&lt;/h4&gt;

&lt;p&gt;Etcd is a very important part of kubernetes master node. It saves the configuration data of kubernetes cluster like which nodes are there,how many pods are there and which pod is running on which node and a lot more information regarding cluster state. Kubernetes master reads and write data to etcd to get the current state and decides the required logical operations to be performed to achieve the desired state.
Etcdctl is a command line interface to manage Etcd through which many operations for etcd can be performed like adding and removing key-value pairs(etcd data storage format is key value pair), verify cluster health, generating database snapshots(As Kubernetes master is highly dependent on etcd for data, so we should have a backup plan for etcd. We can save a snapshot of etcd by using etcdctl save snapshot command).&lt;/p&gt;

&lt;p&gt;Etcd also impelements a &amp;ldquo;watcher&amp;rdquo; feature in which for every key there is a watcher. Whenever key changes, watcher is notified and in return an event is triggered for Api server. After listening to event, api server takes important decisions of operations to be performed to move current state towards desired state.&lt;/p&gt;

&lt;h4 id=&#34;api-server&#34;&gt;Api Server :&lt;/h4&gt;
</description>
    </item>
    
  </channel>
</rss>
