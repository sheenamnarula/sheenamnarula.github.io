
import akka.actor.ActorSystem
import akka.http.scaladsl.Http
import akka.http.scaladsl.model._
import akka.http.scaladsl.server.Directives._
import akka.stream.ActorMaterializer
import scala.io.StdIn
import org.mongodb.scala._

import scala.concurrent.{Await, Promise}
import scala.concurrent.duration.Duration
import scala.util.Success
import scala.util.Failure

import reactivemongo.api._
import reactivemongo.api.collections.default.BSONCollection
import reactivemongo.bson.BSONDocument
import akka.Done
import akka.http.scaladsl.server.Route
import akka.http.scaladsl.server.Directives._
import akka.http.scaladsl.model.StatusCodes
import play.modules.reactivemongo.json.BSONFormats
// for JSON serialization/deserialization following dependency is required:
// "com.typesafe.akka" %% "akka-http-spray-json" % "10.1.7"

import akka.http.scaladsl.marshallers.sprayjson.SprayJsonSupport._
import spray.json.DefaultJsonProtocol._

import scala.io.StdIn

import scala.concurrent.Future

//codecs
import org.mongodb.scala.bson.codecs.Macros
import org.mongodb.scala.bson.codecs.DEFAULT_CODEC_REGISTRY
import org.bson.codecs.configuration.CodecRegistries.{fromRegistries, fromProviders}

    import akka.http.scaladsl.model.StatusCodes
  // for JSON serialization/deserialization following dependency is required:
  // "com.typesafe.akka" %% "akka-http-spray-json" % "10.1.7"

  object marshallingExample {
    val client: MongoClient = MongoClient("mongodb://127.0.0.1:27017")
    // needed to run the route
    implicit val system = ActorSystem()
    implicit val materializer = ActorMaterializer()

    // needed for the future map/flatmap in the end and future in fetchItem and saveOrder
    implicit val executionContext = system.dispatcher

    var orders: List[Item] = Nil

    // domain model
    final case class Item(name: String, _id: String)
    final case class Order(items: List[Item])

    // creating codeec classes
    val itemCodecProvider = Macros.createCodecProvider[Item]()
    val orderCodecProvider = Macros.createCodecProvider[Order]()
//    val codecRegistry = fromRegistries( fromProviders(itemCodecProvider), DEFAULT_CODEC_REGISTRY )
    val codecRegistry = fromRegistries( fromProviders(itemCodecProvider,orderCodecProvider), DEFAULT_CODEC_REGISTRY )


    // formats for unmarshalling and marshalling
    implicit val itemFormat = jsonFormat2(Item)
    implicit val orderFormat = jsonFormat1(Order)

    def fetchItem(itemId: Long): Future[Seq[Item]] = {
       Future  {
      val database: MongoDatabase = client.getDatabase("test")
      val collection: MongoCollection[BSONDocument] = database.getCollection("notifications")
        val result = collection.find().toFuture()
        println("result ==>",result)

        val report = Await.result(result, Duration(5, java.util.concurrent.TimeUnit.SECONDS))
        // here it will wait before returning furture
        println("report ==>",report)
//        Future{
//          Done
//        }
        report ;

    }
    }


    def saveOrder(order: Item): Future[Done] = {
          println("save ordderrr"+ order.name)

          val database: MongoDatabase = client.getDatabase("test")
          val collection: MongoCollection[Document] = database.getCollection("notifications")

      //    val collection: MongoCollection[Document] = database.getCollection("notifications")

          val document: Document = Document( "name" -> order.name, "nickName"-> order.name)
          val insertObservable: Observable[Completed] =  collection.insertOne(document)
          val promise = Promise[Boolean]

          insertObservable.subscribe(new Observer[Completed] {
            override def onNext(result: Completed): Unit = {
              println(s"onNext: $result")
              promise.success(true)

            }
            override def onError(e: Throwable): Unit = {
              println(s"onError: $e")
              promise.success(true)

            }
            override def onComplete(): Unit = {
              println("onComplete")
              promise.success(true)
            }

          })
          val future = promise.future
          Await.result(future, Duration(5, java.util.concurrent.TimeUnit.SECONDS))


      Future { Done }
    }

    def main(args: Array[String]) {

      val route: Route =
        get {
          pathPrefix("item" / LongNumber) { id =>
            // there might be no item for a given id
            val saved = fetchItem(1234)

//            onComplete(saved) {
              println("saved==>"+saved)
              complete(convertToString(saved))

              //              case Success(value) => {
//                println("values ==>>",value)
//
//                val start = """"{"names":[{"""
//                val end = """}]}"""
//                val json = value.mkString(start, ",", end)
////                complete(json.toString())
//                complete(convertToString(value))
//              }
//              case Failure(ex)    => complete((s"An error occurred: ${ex.getMessage}"))
//            }

//            println(maybeItem+"hahahah")
//            onSuccess(maybeItem) {
//              case doc:Seq[Document] =>     complete{
//                println("ahahhahahaha"+doc)
//                HttpResponse(entity = HttpEntity(ContentType(MediaTypes.`application/json`), """{"id":"1"}"""))
//              }
//
//              //              case None       => complete(StatusCodes.NotFound)
//            }
          }
        }
          post {
            path("create-order") {
              entity(as[Item]) { order =>
                val saved: Future[Done] = saveOrder(order)
                onComplete(saved) { done =>
                  println(fetchItem(1234))
                  complete("order created")

                }
              }
            }
          }

      val bindingFuture = Http().bindAndHandle(route, "localhost", 8080)
      println(s"Server online at http://localhost:8080/\nPress RETURN to stop...")
      StdIn.readLine() // let it run until user presses return
      bindingFuture
        .flatMap(_.unbind()) // trigger unbinding from the port
        .onComplete(_ â‡’ system.terminate()) // and shutdown when done

    }
     def convertToString(input: Seq[BSONDocument]) : String = {
        input
          .map(f => convertToStringg(f))
          .mkString("[", ",", "]")
      }

      def convertToStringg(input: BSONDocument) : String = {
//        Json.stringify(BSONFormats.toJSON(input))
        BSONFormats.toJSON(input).toString()
      }
  }

